fegen toy;

@header{
    #include <stdio.h>
}

typedef toy.struct {
    parameters [list<Type> elemTypes]
    // optional
    assemblyFormat ['`<`custom<ElementTypes>($elemTypes)`>`']
}

typeTemplate Toy_Type = AnyTypeOf<[tensor, toy.struct]>;

module
    : structDefine* funDefine+
    ;

structDefine
    : Struct Identifier BracketOpen (varDecl Semicolon)* BracketClose
    ;

expression
    : Number
    {   inputs [doubleAttr numberAttr]
        returns [tensor ret]
        actions {
            'double' number = function<'std::stod'>($Number().text);
            numberAttr = doubleAttr<number>;
        }
        ir [toy.constant]
    }
    | tensorLiteral
    {
        inputs [doubleAttr in]
        returns [tensor]
        actions {
            in = function<'getTensor'>($tensorLiteral());
        }
        ir [operation<toy.constant>]
    }
    | identifierExpr
    {
        inputs [tensor in]
        returns [tensor ret]
        actions {ret = in;}
    }
    | expression Mul expression
    {
        inputs [tensor, tensor]
        returns [tensor]
        ir [toy.mul]
    }
    | expression Add expression
    {
        inputs [tensor, tensor]
        returns [tensor]
        ir [toy.add]
    }
    | expression Dot expression
    {
        inputs [toy.struct input, I64Attr index]
        returns [tensor output] 
        actions {
            index = function<'getMemberIndex'>($expression(1).text);
        }
        ir [toy.StructAccessOp]
    }
    | structLiteral
    {
        inputs [ArrayAttr]
        returns [toy.struct ret]
        actions {
            list<Type> t = function<'getConstantType'>($ctx())
            ret.type =  toy.struct<t>
        }
        ir [toy.StructConstantOp]
    }
    ;

identifierExpr
    : Identifier
    {
        returns [Toy_Type in]
        actions {
            in = function<'findSymbol'>($Identifier().text);
        }
    }
    | Identifier ParentheseOpen (expression(Comma expression)*)? ParentheseClose 
    {
        inputs [FlatSymbolRefAttr callee, list<Toy_Type> ins]
        returns [Toy_Type ret]
        actions {
            // TODO: use custom builder
            // TODO: table
            callee = function<'findSymbol'>($Identifier().text);
            // TODO: how to get a list
            ins = getInputs($expression());
        }
        ir [toy.GenericCallOp]
    }
    ; 

returnExpr
    : Return
    {
        inputs [Toy_Type in]
        ir [toy.ReturnOp]
    } 
    | Return expression 
    {
        inputs [Toy_Type in]
        ir [toy.ReturnOp]
    }
    ;

tensorLiteral
    : SbracketOpen (tensorLiteral (Comma tensorLiteral)*)? SbracketClose 
    | Number 
    ;

toy_type
    : AngleBracketsOpen Number (Comma Number)* AngleBracketsClose
    ;

funDefine
    : prototype block
    {
        inputs [SymbolNameAttr ,TypeAttrOf<FunctionType>]
        actions {
            // TODO: block
        }
        ir [FuncOp]
    }
    ;

prototype
    : Def funcName funcParams
    {
        inputs [SymbolNameAttr ,TypeAttrOf<FunctionType>]
        returns[SymbolNameAttr, TypeAttrOf<FunctionType>]
    }
    ;

funcName
    : Identifier
    {
        returns [SymbolNameAttr sym_name]
        actions {
            sym_name = SymbolNameAttr<$Identifier().text>;
        }
    }
    ;

funcParams
    : ParentheseOpen declList? ParentheseClose
    {
        returns [
            TypeAttrOf<FunctionType> function_type,
            ]
        actions {
            list<Type> argTypes = function<'getArgTypes'>($declList())
            function_type = function<'builder.getFunctionType'>(argTypes, 'std::nullopt');
        }
    }   
    ;

declList
    : varDecl (Comma varDecl)*
    ;

varDecl
    : Var Identifier (toy_type)? (Equal expression)?
    | Identifier Identifier (Equal expression)?
    | Identifier
    ;

block
    : BracketOpen (blockExpr Semicolon)* BracketClose
    ;
    
blockExpr
    : varDecl 
    | returnExpr 
    | Expression
    ;

ParentheseOpen 
    : '('
    ;

ParentheseClose 
    : ')'
    ;

BracketOpen 
    : '{'
    ;

BracketClose 
    : '}'
    ;

SbracketOpen 
    : '['
    ;

SbracketClose 
    : ']'
    ;

Return
    : 'return'
    ;
    
Semicolon
    : ';'
    ;

Var 
    : 'var'
    ;

Def 
    : 'def'
    ;

Struct 
    : 'struct'
    ;

Identifier
    : ('a'..'z' | 'A'..'Z')('a'..'z' | 'A'..'Z' | '0'..'9' | '_')
    ; 

Number
    : ('0'..'9')+
    ;

Equal
    : '='
    ;

AngleBracketsOpen 
    : '<'
    ;

AngleBracketsClose
    : '>' 
    ;

Comma
    : ','
    ;

Add  
    : '+'
    ;

Mul 
    : '*'
    ;

Dot 
    : '.'
    ;

WS
    : ('\r' | '\t' | '\n') -> skip
    ;
    
Comment 
    : '#' .*? '\n' ->skip
    ;